---
created: 2026-02-23
tags:
  - type/note
source: https://leetcode.com/problems/number-of-recent-calls/description/
related:
area:
up:
---
```go
type RecentCounter struct {
	d *Deque
}

func Constructor() RecentCounter {
	return RecentCounter{
		d: NewDeque(),
	}
}

func (this *RecentCounter) Ping(t int) int {
	this.d.PushBack(t, t)

	window := t - 3000
	for this.d.Size > 0 && this.d.Head.Key < window {
		this.d.PopFront()
	}

	return this.d.Size
}

type Node struct {
	Key   int
	Value int
	Next  *Node
	Prev  *Node
}

type Deque struct {
	Head *Node
	Tail *Node
	Size int
}

func NewDeque() *Deque {
	return &Deque{
		Head: nil,
		Tail: nil,
		Size: 0,
	}
}

func (d *Deque) PushBack(key, value int) {
	node := &Node{
		Key:   key,
		Value: value,
	}
	if d.Size == 0 {
		d.Head = node
		d.Tail = node
		d.Size++
		return
	}

	node.Prev = d.Tail
	d.Tail.Next = node
	d.Tail = node
	d.Size++
}

func (d *Deque) PushFront(key, value int) {
	node := &Node{
		Key:   key,
		Value: value,
	}
	if d.Size == 0 {
		d.Head = node
		d.Tail = node
		d.Size++
		return
	}

	node.Next = d.Head
	d.Head.Prev = node
	d.Head = node
	d.Size++
}

func (d *Deque) PopBack() *Node {
	if d.Size == 0 {
		return nil
	}
	node := d.Tail
	if d.Size == 1 {
		d.Head = nil
		d.Tail = nil
		d.Size--
		return node
	}

	d.Tail = node.Prev
	d.Tail.Next = nil
	node.Prev = nil
	d.Size--
	return node
}

func (d *Deque) PopFront() *Node {
	if d.Size == 0 {
		return nil
	}
	node := d.Head
	if d.Size == 1 {
		d.Head = nil
		d.Tail = nil
		d.Size--
		return node
	}

	d.Head = node.Next
	d.Head.Prev = nil
	node.Next = nil
	d.Size--
	return node
}


/**
 * Your RecentCounter object will be instantiated and called as such:
 * obj := Constructor();
 * param_1 := obj.Ping(t);
 */
```