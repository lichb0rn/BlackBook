---
tags:
  - type/note
domain: "[[Golang]]"
topics:
sources:
---
There is a key distinction in Go backend architecture:
1. **Internal Fan-Out (Synchronous):** You have one request and want to do 10 things in parallel _before_ responding to the user. You use a local `errgroup` for this.  
2. **Background Processing (Asynchronous):** You want to tell the user "I've started" (202 Accepted) and then do the work in the background. **This is where you use the `BackgroundWorker`.**

### 1. The Interface and Service
**`internal/spares/service.go`**
```go
package spares

import (
	"context"
	"fmt"
	"yourproject/internal/models"
	"golang.org/x/sync/errgroup"
)

// BackgroundWorker allows the service to offload tasks to the app's main lifecycle
type BackgroundWorker interface {
	Execute(fn func(ctx context.Context) error)
}

type Service struct {
	worker BackgroundWorker
}

func NewService(w BackgroundWorker) *Service {
	return &Service{worker: w}
}

// METHOD A: Synchronous Fan-Out
// Use this when the user is WAITING for a response.
// It uses a LOCAL errgroup to manage its own children.
func (s *Service) CalculateMultiPartSpares(ctx context.Context, components []models.Component) ([]models.CalculationResult, error) {
	g, gCtx := errgroup.WithContext(ctx)
	results := make([]models.CalculationResult, len(components))

	for i, comp := range components {
		i, comp := i, comp
		g.Go(func() error {
			res, err := s.calculateSinglePart(gCtx, comp)
			if err != nil {
				return err
			}
			results[i] = res
			return nil
		})
	}

	if err := g.Wait(); err != nil {
		return nil, err
	}
	return results, nil
}

// METHOD B: Asynchronous Background Job
// Use this when you want to return "202 Accepted" immediately.
// THIS is where we use the injected BackgroundWorker.
func (s *Service) ScheduleHeavyRecalculation(components []models.Component) {
	// We offload the entire process to the app's background group.
	// This ensures it survives even after the HTTP request that triggered it finishes.
	s.worker.Execute(func(ctx context.Context) error {
		// Even though this is backgrounded, it can STILL use 
		// internal fan-out for speed!
		_, err := s.CalculateMultiPartSpares(ctx, components)
		if err != nil {
			// In background tasks, we log errors instead of returning them to users
			fmt.Printf("background calculation failed: %v\n", err)
		}
		return err
	})
}

func (s *Service) calculateSinglePart(ctx context.Context, c models.Component) (models.CalculationResult, error) {
	// Business logic...
	return models.CalculationResult{ComponentID: c.ID, SpareCount: c.Count / 10}, nil
}
```

### 2. The Application Implementation
**`cmd/api/api.go`**
```go
package main

import (
	"context"
	"fmt"
)

// Execute implements spares.BackgroundWorker.
// It bridges the service to the application's global errgroup.
func (app *application) Execute(fn func(ctx context.Context) error) {
	app.group.Go(func() (err error) {
		defer func() {
			if r := recover(); r != nil {
				app.logger.Error("panic in background task", "recovery", r)
				err = fmt.Errorf("panic: %v", r)
			}
		}()

		// We pass app.ctx because background tasks must be tied 
		// to the app's lifespan, not a specific HTTP request's lifespan.
		return fn(app.ctx)
	})
}
```

### 3. Usage in Handlers
**`cmd/api/calculations.go`**

This illustrates why we have both:
```go
// Endpoint: GET /calculate-now
// The user waits. We use the internal fan-out.
func (app *application) handleSyncCalc(w http.ResponseWriter, r *http.Request) {
    components := []models.Component{{ID: "1", Count: 100}}
    
    // USES INTERNAL CONCURRENCY
    results, err := app.service.CalculateMultiPartSpares(r.Context(), components)
    if err != nil {
        app.serverErrorResponse(w, r, err)
        return
    }
    app.writeJSON(w, http.StatusOK, results, nil)
}

// Endpoint: POST /calculate-async
// We return immediately. We use the BackgroundWorker.
func (app *application) handleAsyncCalc(w http.ResponseWriter, r *http.Request) {
    components := []models.Component{{ID: "1", Count: 100}}

    // OFFSETS TO BACKGROUND WORKER
    app.service.ScheduleHeavyRecalculation(components)

    app.writeJSON(w, http.StatusAccepted, "Processing started", nil)
}
```