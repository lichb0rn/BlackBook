---
aliases: ["куча Фибоначчи", "биноминальная куча"]
tags: ["#"""]
---

MOC: [[Двоичная куча]]

---

source: https://www.youtube.com/watch?v=BHbmxWe56T

## Следствие кучи

- Не существует основанной на сравнениях реализации кучи, которая бы отвечала на `extractMin` за $O(1)$ и при этом могла бы делать `insert` за $O(n)$. Иначе был бы алгоритм сортировки за $O(n)$.
- Если бы знали, что храним только числа, то мы можем реализовать кучу с помощью bucket'ов[^1] . Но тогда эта куча была бы не на сравнениях.

```swift
func exchange(int u, int v) {
	// num() - возвращает идентификатор вершины в куче
	int k = num(u)
	int m = num(v)
	swap(num(u), num(v))
	// pointer() - указатель на вершину в куче
	swap(pointer(u), pointer(v))
	swap(a[u], a[v])
}
```

```swift
func siftUp( int v) {
	while v != 1 {
		if a[v] > a[v/2] {
			exchange(v, v/2)
			v /= 2
		} else {
			break
		}
	}
}
```

## Удаление элемента из кучи

- удаление по указателю (по идентификатору)
- удаление по значению
  При удалении по указателю мы меняем целевой указатель с максимальным элементом (последний элемент в массиве) и запускаем `siftDown`

#### Удаление по значению

В куче нет метода поиска `find(x)`. Поэтому мы заводим вторую кучу - кучу удалённых.
Пусть начальная куча - `A`, куча удалённых - `D`

```swift
func getMin() {
	while A.getMin() == D.getMin() {
		A.extractMin()
		D.extractMin()
	}
	return A.getMin()
}
```

Это работает при корректности запросов, т.е. несуществующие элементы не должны удаляться.

## [[Куча Фибоначчи]]

Позволяет выполнять `decreaseKey` за $O(1)$ - амортизировано (суммарно, но каждый конкретный может работать дольше)
Остальные операции - $O(log \ n)$.

## [[Биноминальная куча]]

Кроме обычных операций кучи (`insert`, `getMin`, `extractMin`, `decreaseKey`) умеет делать `merge`: объединить две кучи без дублирования.

_Биноминальное дерево порядка k_ ($T_k$). _Биномиальное дерево_ высоты _h = 0_ состоит из одной единственной вершины, _биномиальное дерево_ _Bk_ высоты _h = k_ образуется присоединением _биномиального дерева_ высоты _k-1_ к корню другого _биномиального дерева_ высоты _k-1_. Ниже показаны _биномиальные деревья_ _B0, B1, B2, B3 и B4_.
![](https://images4.russianblogs.com/865/e1/e1afc959c675d936e2b1012ae051b679.png)

Дерево биноминальное потому, что на $m-м$ уровне $T_k$ находится $C^k_m$ вершин.
_Требование кучи_: число, записанное в вершине $v$ не превосходит чисел, записанных в поддереве $v$.
Биноминальная куча - набор биноминальных деревьев попарно различных порядков.
Например: $T_2$ и $T_3$, но не $T_1, T_2, T_2$.

```swift
func getMin() {
	// ищем минимальный корень среди всех деревьев
}
```

Если в куче $n$ элементов, то все деревья в куче имеет порядок $\leq \log_2n$.
Всего деревьев в куче $\leq \log_2n$.
`getMin()` - $O(log_2n)$

```swift
func decreaseKey(ptr, delta) {

}
```

Время выполнения - $O(log_2n)$.

```swift
// H1, H2 - набор биноминальных деревьев
func merge(H1, H2) {
	// Если деревья одного порядка, то смотрим у кого корень меньше и к нему подвешиваем
	// второе дерево. Например, T2+T2 -> T3
	// H1 - список деревьев t1[0]...t1[logn]
	// H2 - t2[0]...t2[logn]
	carry = -1 //перенос
	for i = 0...logn + 1 {

	}
}
```

---

[1]: [[Поразрядная сортировка|radix]]
