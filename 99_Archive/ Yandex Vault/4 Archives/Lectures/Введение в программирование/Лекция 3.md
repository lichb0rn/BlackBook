---
aliases: ["mergesort", "quicksort"]
tags: ["#"""]
---

MOC: [[Алгоритмы сортировки]]

---

source: https://www.youtube.com/watch?v=TEsRwziPhbo&l

## Теория сортировки

- Любой алгоритм сортировки, основанный на сравнениях, на массиве длины $n$ требует в худшем случае $\Omega (n \ log \ n)$[[Алгоритмическая сложность]] сравнений.

## Mergesort

```swift
func MergeSort(A) {
	if A == 1 {
		return
	}
	else  {
		B, C // две половинки A
		B1 = MergeSort(B)
		C1 = MergeSort(C)
		Merge(B, C, A)
	}
}
func Merge(B, C, A) {
	i = 0, j = 0 //указатели на места в B и C
	p = 0 // указатель в A

	while i < len(B) && j < len(C) {
		if B[i] < C[j] {
			A[p] = B[i]
			p += 1
			i += 1
		} else {
			A[p] = C[j]
			p += 1
			j += 1
		}
	}
	while i < len(B) {
		A[p] = B[i]
		p += 1
		i += 1
	}
	while j < len(C) {
		A[p] = C[j]
		p += 1
		j += 1
	}
}
```

`Merge(B, C)` работает за $\Theta(n)$
Общее время работы - $O(n \ log \ n)$

## QuickSort

```swift
func quickSort(A) {
	let x // случайный элемент A
	partition(A, x)
	let B // числа < x
	let C // числа > x
	quickSort(B)
	quickSort(C)
}
```

В худшем случае $O(n^2)$, когда `x` каждый раз - самый минимальный элемент.
В среднем работает за $O(n \ log \ n)$.
