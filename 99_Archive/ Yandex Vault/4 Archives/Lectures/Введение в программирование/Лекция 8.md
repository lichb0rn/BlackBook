---
aliases: ["дерево отрезков", "отложенные операции", "segment tree", "lazy propagation", "fractional cascading"]
tags: ["#"""]
---

MOC: [[]

---

source: https://www.youtube.com/watch?v=Yy6Uu0d1Gg8&list

## Дерево отрезков

Дан массив: $a_0, a_1,..., a_{n-1}$
Операции:

- `pos`, `val` - найти $a_{pos}=val$
- `(l, r)` - найти $a_l+a_{l+1}+...+a_r$

Для удобства представим, что $n$ - степень двойки.
Объединяем все элементы попарно общей вершине в виде [[Бинарное дерево]]. В вершине храним сумму присоединённых элементов. И так далее до корня, в котором будет сумма всех чисел.
Тогда, если мы делаем `pos,val`, то чтобы корректно изменить все суммы, мы во всех вершинах на пути к `pos` делаем `+=val-a[pos]`, т.е. добавляем новое значение и вычитаем старое (или добавляем разницу между новым и старым).
Запрос типа `(l, r)`:
Допустим есть вершина `v` с сыновьями `2v` и `2v+1`. В вершине мы храним информацию о том, какой отрезок она контролирует: `[tl, tr]`. Тогда левый сын контролирует отрезок `[tl, tm]`, а правый - `[tm+1, tr]`. Где `tm=[tl+tr]>>1`.
Пусть `t[v]` - сумма в вершине `v`, тогда:

```c++
void update(int v, int tl, int tr, int pos, int delta) {
	t[v] += delta
	if (tl == tr) return;
	int tm = (tl+tr) >> 1;
	// Случай, когда нужно идти в левого сына
	if (pos <= tm) update(v*2, tl, tm, pos, delta);
	else update(v*2+1, tm, tr, pos, delta);
}
```

Время работы: $O(log_2n)$

```c++
int getSum(int v, int tl, int tr, int l, int r) {
	// Если мы пришли в вершину, отвчающую за отрезок, то в ней уже есть сумма
	if (tl == l && tr == r) {
		return t[v]
	}
	int tm = (tl + tr) >> 1;
	int answer = 0;
	if (l <= tm) {
		answer += getSum(v*2, tl, tm, l, min(r, tm));
	}
	// Если нужно идти вправо
	if (r >= tm + 1) answer += getSum(2*v+1, tm+1, tr, max(l, tm+1), r);
	return answer;
}
```

Время работы: $O(log_2n)$.

## k-й ноль на отрезке

Пусть все числа в массиве - нули и единицы.
Запросы:

- `pos, val` поменять pos на val
- `l,r,k` - найти позицию k-го нуля на отрезке `[l, r]`

Также используем [[Лекция 8|дерево отрезков]], но теперь в вершине храним - количество нулей: `t[v]`

- Достаточно искать k-й ноль от l-го элемента и до конца массива.
- Чтобы найти k-й ноль начиная с l-го элемента, достаточно найти (m+k)-й ноль с начала массива, где m - количество нулей от нулевого элемента до l-1.
  В итоге ищем K-й ноль от начала массива.

Сначала пытаемся понять, если слева хотя бы k нулей:

```c++
if (k >= t[v*2]) {
	return get(v*2, tl, tm, k);
} else {
	return get(2*v+1, tm+1, tr, k-t[v*2])
}
```

Работает за $O(log_2n)$.

## Отложенные операции

Пусть есть массив $a_0, a_1, ...$
Поступают запросы:

- найти сумму на отрезке `getSum(l, r)`
- `assign(l, r, x)` - заменить все числа на отрезке на `x`
  Будем в вершина делать пометку `promise=x` - обещание заменить все вершины в поддереве на `x`.
  Пусть `pro[v]` - отложенная операция в `[v]`.

```c++
// протолкнуть инфу о promise
void push(int v, int tl, int tr) {
	// пусть отсутствие изменений = pro[v] = -1
	if (pro[v] == -1) {
		return;
	}
	int x = pro[v];
	int tm=(tl+tr) >> 1;
	t[v*2] = x * (tm-tl+1);
	t[v*2+1] = x * (tr - tm);
	pro[v*2] = pro[v*2+1] = x;
	pro[v] = -1;
}
```

```c++
void assign(int v, int tl, int tr, int l, int r, int x) {
	if (tl == l && tr == r) {
		pro[v] = x;
		t[v] = x * (tr - tl + 1)
		return;
	}
	push(v, tl, tr);
	int tm = (tl + tr) >> 1;
	if (l <= tm) assign(v*2, tl, tm, l, min(r, tm), x);
	if (r > tm) assign(v*2+1, tm+1, tr, max(l, tm+1), x);
	t[v] = t[v*2] + t[v*2+1];
}
```

В `getSum` перед спуском в детей нужно сделать `push`.

## Количество чисел на отрезке, значения которых лежат в отрезке

Пусть есть статический массив $a_0, a_1, ...$.
Всего один запрос:

- `l,r,x,y` - найти количество k, таких что $l \leq k \leq r, x \leq a_k \leq y$/
  С помощью таких запросов можно считать количество различных чисел на отрезке.
  Количество чисел на отрезке `[x, y]` = (количество чисел $\geq x$) - (количество чисел $\geq y + 1$).

Тут понадобится дерево MergeSort или Fractional Cascading.
В корне дерева хранится весь отсортированный массив. В в вершинах поддеревьев хранятся отсортированные части массива. В каждом отсортированном массиве с помощью [[Бинарный поиск]] числа $\geq x$.
Время работы: $O(log_2^2n)$,
Построение дерева: $O(nlog_2n)$. Память: $O(nlog_2n)$.
Для каждого числа $y$ храним 2 индекса: на минимальные числа $\geq y$ в обоих потомках.
