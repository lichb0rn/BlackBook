---
aliases: ["dijkstra", "дийкстра", "поиск пути"]
---
MOC:  [[Обход графа]]

---

# Алгоритм Дийкстры для поиска кратчайшего пути в графе
Производительность: **$O(E \ log V)$**

## Описание:
### Инициализация
- Алгоритм начинается с вершины (допустим, $a$) и заканчивается после того, как все вершины графа пройдены.
- Каждой вершине присваивается метка $L$ - минимальное расстояние от этой вершины до $a$.
- На первом шаге присваиваем метку $L(a) = 0$, метки всех остальных вершин - $\infty$. Так мы показываем, что расстояние до остальных вершин от $a$ пока неизвестно.
### Шаги
- Если все вершины пройдены, то алгоритм завершается. В противном случае выбираем вершину $current$, которая имеет минимальную метку. На первом шаге это - $a$: `current = a`
- Для `current` выбираем всех непосещенных соседей и подсчитываем метки:
пусть `current -> B = 2`, `current -> C = 4` Расстояние до $B$ меньше, `L(B) = current + B = 0 + 2`
- Переходим к `B` и повторяем предыдущий шаг для этой вершины и так до тех пор, пока не останется непройденных вершин.

## Код
```swift
public enum Visit<T: Hashable> {
    case start
    case edge(Edge<T>)
}

public class Dijkstra<T: Hashable> {
    
    public typealias Graph = AdjacencyList<T>
    let graph: Graph
    
    public init(graph: Graph) {
        self.graph = graph
    }
    
    
    // Трек пути до назначения
    private func route(to destination: Vertex<T>, 
					   with paths: [Vertex<T>: Visit<T>]) -> [Edge<T>] {
        var vertex = destination
        var path: [Edge<T>] = []
        
        while let visit = paths[vertex], case .edge(let edge) = visit {
            path = [edge] + path
            vertex = edge.source
        }
        
        return path
    }
    
    // Подсчёт суммарного веса для пути
    private func distance(to destination: Vertex<T>, 
						  with paths: [Vertex<T>: Visit<T>]) -> Double {

        let path = route(to: destination, with: paths)
        let distances = path.compactMap { $0.weight }
        return distances.reduce(0.0, +)
    }


    public func shortestPath(from start: Vertex<T>) -> [Vertex<T>: Visit<T>] {

        var paths: [Vertex<T>: Visit<T>] = [start: .start]
        
        //Очередь с приоритетом для хранения вершин, которые нужно пройти
        var priorityQueue = PriorityQueue<Vertex<T>>(sort: {
            self.distance(to: $0, with: paths) < self.distance(to: $1, with: paths)
        })
        priorityQueue.enqueue(start)
        
        // Продолжаем, пока все вершины не будут пройдены
        // Т.е. есть что извлекать из очереди
        while let vertex = priorityQueue.dequeue() {
            for edge in graph.edges(from: vertex) {
                guard let weight = edge.weight else {
                    continue
                }
                
                if paths[edge.destination] == nil ||
                    distance(to: vertex, with: paths) + weight < 
					distance(to: edge.destination, with: paths) {
                    
                    paths[edge.destination] = .edge(edge)
                    priorityQueue.enqueue(edge.destination)
                }
            }
        }
        
        return paths
    }
    
    public func shortestPath(to destination: Vertex<T>, 
							 paths: [Vertex<T>: Visit<T>]) -> [Edge<T>] {

        return route(to: destination, with: paths)
    }
}```