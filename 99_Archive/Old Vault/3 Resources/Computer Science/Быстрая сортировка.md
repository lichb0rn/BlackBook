---
aliases: ["quick sort", "быстрая сортировка", "lomuto's algorithm", "hoare's algorithm"]
---
MOC:  [[Алгоритмы сортировки]]

---
 **Среднее время выполнения:** $O(n \ logn)$
 **Худшее время:** $O(n^2)$
 
 Быстрая сортировка основана на разбиение массива на 3 части: точка опоры, элементы меньше точки опоры и элементы больше точки опоры

 < pivot | pivot | > pivot
 | :-: | :-: | :-: |

 
 ## Простейший вариант исполнения
 ```swift
 public func quicksortNaive<T: Comparable>(_ a: [T]) -> [T] {
    guard a.count > 1 else {
        return a
    }
    let pivot = a[a.count / 2]
    let less = a.filter { $0 < pivot }
    let equal = a.filter { $0 == pivot }
    let greater = a.filter { $0 > pivot }
    return quicksortNaive(less) + equal + quicksortNaive(greater)
}
 ```
 
 В простейшем варианте исполнения есть минусы:
 - вызов `filter` 3 раза на одном массиве - не слишком эффективно;
 - создание отдельного массива для каждой партиции - не очень эффективно по памяти;
 - выбор среднего элемента - не всегда эффективная стратегия.

## Алгоритм разбиения Ломуто  
Алгоритм Ломуто всегда выбирает *последний* элемент в качестве *pivot*.

Алгоритм принимает на входе:
- массив для разбиения;
- `low` и `high` задают диапазон внутри массива для разбиения. Это диапазон будет уменьшаться с каждым шагом рекурсии.

На выходе алгоритм возвращает индекс `pivot`.

```swift
public func partitionLomuto<T: Comparable>(_ a: inout [T],
							low: Int, high: Int) -> Int {
    let pivot = a[high]
    
    var i = low
    for j in low..<high {
        if a[j] <= pivot {
            a.swapAt(i, j)
            i += 1
        }
    }
    
    a.swapAt(i, high)
    return i
}

```

Алгоритм разбивает массив на 4 части:
- `a[low..<i]` содержит все элементы <= `pivot`
- `a[i..j-1]` - все элементы > `pivot`
- `a[j...high-1]` - элементы, которые не были проверены
- `a[high]` - `pivot`

values <= pivot | values > pivot | not compared yet | pivot
| :-: | :-: | :-: | :-: |
i .. i-1 | i .. j-1 | j .. high-1 | high

*quicksort* на алгоритме Ломуто:
```swift
public func quicksortLomuto<T: Comparable>(_ a: inout [T], 
											low: Int, high: Int) {
    if low < high {
        let pivot = partitionLomuto(&a, low: low, high: high)
        quicksortLomuto(&a, low: low, high: pivot - 1)
        quicksortLomuto(&a, low: pivot + 1, high: high)
    }
}
```

## Алгоритм Хоара
В алгоритме Хоара всегда выбирается *первый* элемент в качестве `pivot`.

Алгоритм:
- Первый элемент выбираем в качестве `pivot`
- Индексы `i` и `j` определяют два региона:
	- все индексы перед `i` будут *$\leq$* `pivot`
	- все индексы после `j` будут *$>$* `pivot`

==Замечание== 
- Индекс возвращаемый `partitionHoare()` не обязательно является `pivot`.

```swift
public func partitionHoare<T: Comparable>(_ a: inout [T],
                                          low: Int, high: Int) -> Int {
    
    let pivot = a[low]
    var i = low - 1
    var j = high + 1
    
    while true {
        
        repeat { j -= 1 } while a[j] > pivot
        repeat { i += 1 } while a[i] < pivot
        
        if i < j {
            a.swapAt(i, j)
        } else {
            return j
        }
    }
}

public func quicksortHoare<T: Comparable>(_ a: inout [T],
                                          low: Int, high: Int) {
    
    if low < high {
        let p  = partitionHoare(&a, low: low, high: high)
        quicksortHoare(&a, low: low, high: p)
        quicksortHoare(&a, low: p + 1, high: high)
    }
}
```

## Разделение Голландского флага (3 way quicksort)

Идея основана на [[Алгоритм Голландского флага|алгоритме Голландского флага]].
Коллекция делия на участки:
- `[low..<smaller]` - элементы $<$ `pivot`
- `[smaller..<equal]` - элементы $=$ `pivot`
- `[larger>..high]` - элементы $>$ `pivot`
- `[equal...larger]` - ещё не проверенные.


```swift
public func partitionDutchFlag<T: Comparable>(_ a: inout [T],
                                              low: Int, high: Int,
                                              pivotIndex: Int) -> (Int, Int) {
    
    let pivot = a[pivotIndex]
    var smaller = low
    var equal = low
    var larger = high
    while equal <= larger {
        
        if a[equal] < pivot {
            a.swapAt(smaller, equal)
            smaller += 1
            equal += 1
        } else if a[equal] == pivot {
            equal += 1
        } else {
            a.swapAt(equal, larger)
            larger -= 1
        }
    }
    
    return (smaller, larger)
}

public func quicksortDutchFlag<T: Comparable>(_ a: inout [T],
                                              low: Int, high: Int) {
    
    if low < high {
        let (middleFirst, middleLast) = partitionDutchFlag(&a, low: low, high: high, pivotIndex: high)
        quicksortDutchFlag(&a, low: low, high: middleFirst - 1)
        quicksortDutchFlag(&a, low: middleLast + 1, high: high)
    }
}
```