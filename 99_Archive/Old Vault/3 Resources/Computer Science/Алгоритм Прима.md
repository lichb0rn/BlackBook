---
aliases: ["prim", "Прим"]
---
MOC:  [[Графы (реализация)]]

---

# Алгоритм Прима

## Производительность
- Время выполнения: *$O(E \ log\ E)$*

## Описание

Алгоритм Прима - это [[Жадные алгоритмы|жадный]] алгоритм для построения минимального [[Остовное дерево|остовного дерева]].

На вход алгоритма подаётся связный неориентированный граф. Для каждого ребра задаётся его стоимость.

Сначала берётся произвольная вершина и находится ребро, инцидентное данной вершине и обладающее наименьшей стоимостью. Найденное ребро и соединяемые им две вершины образуют дерево. Затем, рассматриваются рёбра графа, один конец которых — уже принадлежащая дереву вершина, а другой — нет; из этих рёбер выбирается ребро наименьшей стоимости. Выбираемое на каждом шаге ребро присоединяется к дереву. Рост дерева происходит до тех пор, пока не будут исчерпаны все вершины исходного графа.

Результатом работы алгоритма является остовное дерево минимальной стоимости.

## Код
```swift
public class Prim<T: Hashable> {
    
    public typealias Graph = AdjacencyList<T>
    public init() { }
    
    public func produceMinimumSpanningTree(for graph: Graph) 
-> (cost: Double, mst: Graph) {

        var cost = 0.0
        let mst = Graph()
        var visited: Set<Vertex<T>> = []
        
        // Очередь с приоритетом используется для хранения ребёр пройденных вершин
        // Каждый раз она даёт ребро с минимальным весом
        var priorityQueue = PriorityQueue<Edge<T>>(sort: {
            $0.weight ?? 0.0 < $1.weight ?? 0.0
        })
        
        // Копируем все вершины из оригинального графа в дерево
        mst.copyVertices(from: graph)
        
        guard let start = graph.vertices.first else {
            return (cost: cost, mst: mst)
        }
        
        visited.insert(start)
        // Добавляем все потенциальные ребра от начала в очередь с приоритетом
        addAvailableEfges(for: start,
                             in: graph,
                             check: visited,
                             to: &priorityQueue)
        
        while let smallestEdge = priorityQueue.dequeue() {
            let vertex = smallestEdge.destination
            guard !visited.contains(vertex) else {
                continue
            }
            
            visited.insert(vertex)
            cost += smallestEdge.weight ?? 0.0
            
            mst.add(.undirected,
                    from: smallestEdge.source,
                    to: smallestEdge.destination,
                    weight: smallestEdge.weight)
            
            addAvailableEfges(for: vertex,
                                 in: graph,
                                 check: visited,
                                 to: &priorityQueue)
        }
        
        return (cost: cost, mst: mst)
    }
    
    
    internal func addAvailableEfges(for vertex: Vertex<T>, in graph: Graph,
                                    check visited: Set<Vertex<T>>,
                                    to priorityQueue: inout PriorityQueue<Edge<T>>) {
        
        for edge in graph.edges(from: vertex) {
            if !visited.contains(edge.destination) {
                priorityQueue.enqueue(edge)
            }
        }
    }
}
```