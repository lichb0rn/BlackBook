---
aliases: ["амортизационный анализ", "метод монеток", "метод потенциалов", "sparse table"]
tags: ["#"""]
---

MOC: [[Биноминальная куча]]

---

source: https://www.youtube.com/watch?v=bYwUFcP5i6s

## [[Амортизационный анализ]]

Допустим $S$ - структура данных, и есть $q$ типов запросов к ней и к каждому запросу есть функция $T_1(n), T_2(n),...$.
Тогда $T_i$ - амортизированное (учетное) время обработки запроса $i-го$ типа, если:
$\forall n \ \forall Q_1, Q_2,...,Q_n$ время обработки этих запросов: $$O^* = \displaystyle\sum_{j=1}^{n} T_{i_j}(n)$$

## Метод монеток (метод бухгалтерского учёта)

Пусть поступают запросы $q_1, q_2, ..., q_n$ и их реальное время обработки $t_1, t_2, ..., t_n$.
Пусть во время обработки $i-го$ запроса мы "кладём на счёт" $d_i$ монет, а также снимаем $w_i$ монет.
Тогда учетная стоимость: $a_i = t_i + d_i - w_i$

### `insert` в биноминальной куче в отсутствии других операций

$O^*(1)$ - каждый, но суммарно $O(n)$.

## Метод потенциалов

Пусть $S$ - структура данных, а $\Phi(S)$ - функция состояния от этой структуры (например, размер массива или длина двоичной записи).
Пусть поступают запросы $Q_1, Q_2, ..., Q_n$. После обработки $i-го$ запроса потенциал = $\Phi_i$.
А $t_i$ - реальное время обработки $i-го$ запроса. Тогда учётное время работы: $$a_i = t_i + \Phi_i - \Phi_{i-1}$$

## [[Sparse table]]

Пусть есть статический (неизменяемый) массив $a_0, a_1, ..., a_n$.
Поступает запрос $l,r$: найти $min(a_l ... a_r)$ (найти минимальное число на отрезке с $l$ по $r$).
Время выполнения: $O(1)$.

- Пусть `sparse[k][i] = min(a[i], a[i+1], ..., a[i+2^k+1])`

Считаем `sparse`:

```swift
sparse[0][i] = a[i]
j = i + 2^k
sparse[k+1][i] = min(sparse[k][i], sparse[k][j])
```

```c++
int a[0... n-1];
for i=0; n-1; i++ {
	sparse[0][i] = a[i]
}
for k=0; log(n); {
	for i=0; n-1 {
		sparse[k+1][i] = min(sparse[k][i], sparse[k][j])
	}
}
```

Ищем минимум на отрезке,

```c++
int getMin(int l, int r) {
	k = max(2^k, r-l+1)
	return min(sparse[k][l], sparse[k][r-2^k+1])
}
```
