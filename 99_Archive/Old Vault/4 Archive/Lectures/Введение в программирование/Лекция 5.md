---
aliases: ["куча", "heap"]
---
MOC:  [[Сортировка кучей (heaprsort)]]

---
source: https://www.youtube.com/watch?v=BAJ-ok27jVc

## Куча
Пусть дано множестве $S$. Задача кучи - отвечать на несколько вопросов:
- insert x - добавить x в $S$
- getMin - вернуть минимальный элемент в $S$
-  extractMin - извлечь минимальный элемент из $S$
- decreaseKey ptr, delta - уменьшить x, лежащий по указателю ptr, на delta

Примеры использования:
 - обработка запросов
 - [[Декартово дерево]]
 - [[Сортировка кучей (heaprsort)|heapsort]]
 - алгоритмы [[Алгоритм Прима]], [[Алгоритм Дийкстры]]

## Бинарная куча
Пусть $S = \{a_1, a_2, a_3, ... , a_n\}$
Хранить будем в виде [[Бинарное дерево|бинарного дерева]]
[![](http://wiki.atp-fivt.org/images/thumb/0/04/BinaryHeapLogo.png/400px-BinaryHeapLogo.png)](http://wiki.atp-fivt.org/index.php/%D0%A4%D0%B0%D0%B9%D0%BB:BinaryHeapLogo.png)
*Сам дерево в явном виде мы не строим.*
У вершины $a_v$ есть два листа: $a_{2v}$ и $a_{2v+1}$.
$a_v$ получается из номера листа с округлением вниз: $2v/2$ или $(2v+1)/2$ (индексация )
Вместо дерева храним массив.
==!!!==Требование: для любого $v$ число, записанное в вершине $v$, должно не превосходить все числа поддерева $v$:
- $a[v] \leq a[2v]$
- $a[v] \leq a[2v+1]$
Тогда `getMin = a[1]`, время $O(1)$.
```swift
func siftUp(v) {
	while v != 1 {
		if a[v] < a[v/2] {
			// если родитель больше, то меняем местам
			swap(a[v], a[v/2])
			// и меняем индекс, чтобы подняться дальше для сравнений
			v /= 2
		} else {
			break
		}
	}
}
```
```swift
func siftDown(v) {
	
}
```